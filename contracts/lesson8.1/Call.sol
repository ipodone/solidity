// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// åˆçº¦é—´è°ƒç”¨
contract Call {
    // æ¥å£è°ƒç”¨ï¼ˆinterfaceï¼‰ï¼šIERC20 public token; constructor(address _token) { token = IERC20(_token); }
    // ï¼ï¼ï¼token = IERC20(_token);   è¿™ç§ç±»å‹è½¬æ¢çš„æ•ˆæœï¼šå½“å‰åˆçº¦ç»™æŸä¸ªåœ°å€è½¬è´¦ æˆ– æŸä¸ªåœ°å€ç»™å½“å‰åˆçº¦è½¬è´¦
    // æ ¸å¿ƒä½œç”¨ï¼šæ¥å£ç»‘å®š - è¿™è¡Œä»£ç å®é™…ä¸Šæ˜¯åœ¨åšä¸¤ä»¶äº‹ï¼š1.åœ°å€åˆ°æ¥å£çš„è½¬æ¢ï¼ˆaddress â†’ interfaceï¼‰ 2.åˆ›å»ºæ¥å£å®ä¾‹ï¼Œç”¨äºè°ƒç”¨ç›®æ ‡åˆçº¦çš„åŠŸèƒ½
    // å®é™…æ•ˆæœ - è½¬æ¢åï¼Œtoken å˜é‡å…·å¤‡äº†ï¼š1.ç±»å‹å®‰å…¨æ€§ - ç¼–è¯‘å™¨çŸ¥é“å®ƒæœ‰ IERC20 çš„æ–¹æ³• 2.è°ƒç”¨èƒ½åŠ› - å¯ä»¥è°ƒç”¨ç›®æ ‡åˆçº¦çš„ ERC20 å‡½æ•° 3.åœ°å€å°è£… - å†…éƒ¨å­˜å‚¨äº†ç›®æ ‡åˆçº¦åœ°å€
    // 
    // ä¸ºä»€ä¹ˆä¼˜å…ˆä½¿ç”¨æ¥å£è°ƒç”¨ï¼šç±»å‹å®‰å…¨ï¼Œä»£ç å¯è¯»æ€§å¥½
    // token = IERC20(_token);   è¿™ä¸ªæ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨åˆ›å»ºä¸€ä¸ªIERC20æ¥å£å®ç°ï¼Œè¿˜æ˜¯ç”¨çš„ä¹‹å‰IERC20è‡ªå·±å·²ç»åˆ›å»ºçš„å®ç° - ç»“è®ºï¼šç”¨çš„æˆ‘ä»¬è‡ªå·±å·²ç»å®ç°å¥½çš„åˆçº¦å®ç°
    // 1. è¿™ä¸€è¡Œä»£ç ï¼šä¸æ˜¯åˆ›å»ºæ–°å®ç°ï¼Œè€Œæ˜¯ç±»å‹è½¬æ¢ï¼Œå³å°†_addressè½¬æ¢ä¸ºIERC20æ¥å£ç±»å‹ - è¿™ç›¸å½“äºå‘Šè¯‰ç¼–è¯‘å™¨ï¼šæŠŠ _token è¿™ä¸ªåœ°å€æŒ‡å‘çš„åˆçº¦å½“ä½œ IERC20 æ¥å£æ¥ä½¿ç”¨
    // 2. å·¥ä½œåŸç†ï¼š
    // address _token = 0x123...abc;  // ä¸€ä¸ªæ™®é€šçš„åœ°å€
    // è½¬æ¢ä¸ºIERC20æ¥å£
    // IERC20 tokenContract = IERC20(_token);
    // ç°åœ¨å¯ä»¥è°ƒç”¨æ¥å£æ–¹æ³•
    // tokenContract.transfer(to, amount);
    // ï¼ï¼ï¼å®é™…ä¸Šè°ƒç”¨çš„æ˜¯ 0x123...abc åœ°å€ä¸Šéƒ¨ç½²çš„åˆçº¦çš„transferå‡½æ•°
    // 3. åº•å±‚å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ
    // ç¼–è¯‘å™¨ä¼šç”Ÿæˆç±»ä¼¼è¿™æ ·çš„ä½çº§è°ƒç”¨ï¼š
    // (bool success, bytes memory data) = _token.call(
    //    abi.encodeWithSignature("transfer(address,uint256)", to, amount)
    // );
    // IERC20(_token) åªæ˜¯æä¾›äº†ä¸€ä¸ªç±»å‹å®‰å…¨çš„åŒ…è£…
    // 4. å®Œæ•´çš„ç¤ºä¾‹åœºæ™¯ï¼šåˆçº¦Aï¼šå®šä¹‰æ¥å£ã€åˆçº¦Bï¼šä»£å¸å®ç°ã€åˆçº¦Cï¼šä½¿ç”¨æ¥å£ - è¿™é‡Œ _tokenAddress å¿…é¡»æ˜¯å®é™…éƒ¨ç½²çš„ MyToken åˆçº¦åœ°å€ï¼Œä¸æ˜¯åˆ›å»ºæ–°çš„ï¼Œè€Œæ˜¯"å¼•ç”¨"å·²å­˜åœ¨çš„åˆçº¦
    // TokenUser.token = IERC20(0x111...); // ï¼ï¼ï¼è¿™åªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨ï¼š"0x111...è¿™ä¸ªåˆçº¦å®ç°äº†IERC20æ¥å£"ï¼Œå¹¶æ²¡æœ‰åˆ›å»ºæ–°çš„åˆçº¦
    // 5. é‡è¦ç‰¹æ€§ï¼šæ¥å£ä¸å­˜å‚¨å®ç°ä»£ç  - ï¼ï¼ï¼è½¬æ¢åªæ˜¯"æ‰¿è¯º"ç›®æ ‡åˆçº¦æœ‰è¿™ä¸ªå‡½æ•°ï¼Œè¿è¡Œæ—¶æ‰ä¼šå®é™…è°ƒç”¨ï¼›è¿è¡Œæ—¶æ£€æŸ¥ - ç¼–è¯‘é€šè¿‡ï¼ˆå› ä¸ºæ¥å£è½¬æ¢ä¸éªŒè¯ï¼‰ï¼Œä½†è°ƒç”¨æ—¶ä¼šå¤±è´¥ï¼Œä¼šrevertæˆ–è¿”å›falseï¼›å¤šä¸ªåˆçº¦å¯ä»¥å…±äº«åŒä¸€æ¥å£
    // 6.1.æ€»ç»“ï¼štoken = IERC20(_token); çš„æ„æ€æ˜¯ï¼š
    // æ²¡æœ‰åˆ›å»ºæ–°åˆçº¦ - é›¶Gasæˆæœ¬ã€åªæ˜¯ç±»å‹è½¬æ¢ - å‘Šè¯‰ç¼–è¯‘å™¨å¦‚ä½•è°ƒç”¨ã€å¼•ç”¨ç°æœ‰åˆçº¦ - å‡è®¾è¯¥åœ°å€æœ‰å¯¹åº”å®ç°ã€è¿è¡Œæ—¶éªŒè¯ - å®é™…è°ƒç”¨æ—¶æ‰æ£€æŸ¥å‡½æ•°æ˜¯å¦å­˜åœ¨
    // 6.2 æ€»ç»“ï¼štoken = IERC20(_token); çš„æ„æ€æ˜¯ï¼š- ECR20æ˜¯åŒè´¨åŒ–ä»£å¸æ ‡å‡†
    // ï¼ï¼ï¼_token æ˜¯ä»£å¸åˆçº¦çš„åœ°å€ï¼ˆaddress ç±»å‹ï¼‰ã€IERC20(_token) å°†è¿™ä¸ªåœ°å€è½¬æ¢ä¸º IERC20 æ¥å£å®ä¾‹ã€token å˜é‡ç°åœ¨æ˜¯ä¸€ä¸ªå¯ä»¥è°ƒç”¨ ERC20 æ–¹æ³•çš„æ¥å£å¯¹è±¡ã€åº•å±‚å®ƒä»ç„¶å­˜å‚¨ç€ç›¸åŒçš„åˆçº¦åœ°å€ï¼Œä½†é€šè¿‡æ¥å£æŠ½è±¡æä¾›äº†ç±»å‹å®‰å…¨å’Œä¾¿æ·çš„æ–¹æ³•è°ƒç”¨




    // åº•å±‚è°ƒç”¨æ–¹æ³•ï¼šcall - å‘é€ä»¥å¤ªå¸ï¼Œä¿®æ”¹çŠ¶æ€|æ‰§è¡Œä¸Šä¸‹æ–‡è¢«è°ƒç”¨åˆçº¦|msg.senderè°ƒç”¨è€…åˆçº¦ã€ï¼ï¼ï¼delegatecallä»£ç†/å§”æ‰˜è°ƒç”¨ - å§”æ‰˜æ‰§è¡Œ|æ‰§è¡Œä¸Šä¸‹æ–‡è°ƒç”¨è€…åˆçº¦|msg.senderåŸå§‹åˆçº¦ - å­˜å‚¨å¸ƒå±€è¦æ±‚å…¼å®¹ã€staticcall - åªè¯»æŸ¥è¯¢|æ‰§è¡Œä¸Šä¸‹æ–‡è¢«è°ƒç”¨åˆçº¦|msg.senderè°ƒç”¨è€…åˆçº¦
    // ï¼ï¼ï¼ç†è§£æ‰§è¡Œä¸Šä¸‹æ–‡ï¼šcall/static call - storageå­˜å‚¨åœ¨è¢«è°ƒç”¨è€…åˆçº¦ä¸­ã€msg.senderä¸ºè°ƒç”¨è€…åˆçº¦ï¼ˆéšç€è°ƒç”¨è€…è€Œå˜ï¼‰ï¼›delegatecall - storageå­˜å‚¨åœ¨ä»£ç†/è°ƒç”¨è€…åˆçº¦ä¸­ã€msg.senderä¸ºåŸå§‹åˆçº¦ï¼ˆä¿æŒä¸å˜ï¼‰
    // åˆçº¦åˆ›å»ºæ–¹å¼ï¼šnew - Token newToken = new Token(name, supply);ã€create2é«˜çº§åº”ç”¨ - Token newToken = new Token{salt: salt}(name, supply);
    // å®‰å…¨çš„å¤–éƒ¨è°ƒç”¨ï¼šé‡å…¥æ”»å‡»é˜²èŒƒ - CEIæ¨¡å¼ä¹‹å…ˆæ›´æ–°ï¼Œå†å‘é€ï¼›é˜²æŠ¤æªæ–½ - æ£€æŸ¥-æ•ˆæœ-äº¤äº’æ¨¡å¼ã€ä½¿ç”¨é‡å…¥é”ã€é™åˆ¶Gasã€æ£€æŸ¥è¿”å›å€¼
    // å®é™…ä½¿ç”¨åœºæ™¯ï¼šä»£å¸äº¤æ¢åˆçº¦ - ä½¿ç”¨æ¥å£è°ƒç”¨ERC20å‡½æ•°ï¼Œå®ç°ä»£å¸çš„äº¤æ¢å’Œè½¬ç§»ï¼›å¤šç­¾é’±åŒ… - ä½¿ç”¨callæ‰§è¡Œå¤–éƒ¨äº¤æ˜“ï¼Œç¡®ä¿å¤šé‡ç­¾åéªŒè¯ï¼›ä»£ç†åˆçº¦ - ä½¿ç”¨delegatecallè½¬å‘è°ƒç”¨ï¼Œå®ç°åˆçº¦å‡çº§å’ŒåŠŸèƒ½æ‰©å±•

    // å‰æï¼šapprove
    // token.transferFrom(msg.sender, address(this), amount) æ˜¯ DeFi å’Œ DApp çš„æ ¸å¿ƒæ“ä½œï¼Œå®ç°äº†ï¼šåˆçº¦æ§åˆ¶ç”¨æˆ·èµ„äº§ï¼ˆéœ€é¢„å…ˆæˆæƒï¼‰ã€å®‰å…¨çš„èµ„é‡‘æ‰˜ç®¡ã€è‡ªåŠ¨åŒ–äº¤æ˜“æ‰§è¡Œ - ä½¿ç”¨å‰ç”¨æˆ·å¿…é¡»å…ˆ approveï¼Œå¦åˆ™äº¤æ˜“ä¼šå¤±è´¥ï¼
    // token.transferFrom(msg.sender, address(this), amount) æ˜¯ ERC20ä»£å¸è½¬è´¦çš„æ ‡å‡†æ“ä½œï¼Œç”¨äºä»ä»–äººè´¦æˆ·å‘å½“å‰åˆçº¦è½¬è´¦
    // msg.sender - ä»˜æ¬¾æ–¹ï¼šå‡½æ•°è°ƒç”¨è€…ã€address(this) - æ”¶æ¬¾æ–¹ï¼šå½“å‰æ™ºèƒ½åˆçº¦ã€amount - é‡‘é¢ï¼šè½¬è´¦æ•°é‡

    // å¤šåˆçº¦é—´è°ƒç”¨ï¼šDefiå»ä¸­å¿ƒåŒ–é¡¹ç›®ä¸­ï¼š1ã€å€Ÿè´·åè®®å¯èƒ½éœ€è¦è°ƒç”¨ä»·æ ¼é¢„è¨€æœºï¼Œè·å–ä¸€ä¸ªå®æ—¶ä»·æ ¼ï¼Œè¿›è¡Œä¸€ä¸ªæ¯”å¯¹ 2ã€è°ƒç”¨ERC20ä»£å¸åˆçº¦è¿›è¡Œä¸€ä¸ªèµ„é‡‘è½¬ç§» 3ã€è°ƒç”¨æµåŠ¨æ€§æ± ï¼Œè¿›è¡Œä¸€ä¸ªæ¸…ç®—
    // Javaï¼šåˆçº§ã€ä¸­çº§ã€é«˜çº§ - æŠ€æœ¯ã€ä¸šåŠ¡ã€ç®¡ç†ï¼ˆéƒ½ç®—ä¸­çº§ï¼‰- ä»¥åæ’é™¤ç®¡ç†
    // Web3ï¼š
    // ä¸šåŠ¡é€»è¾‘åˆçº¦ã€å¤–éƒ¨åˆçº¦ - ERC20ä»£å¸åˆçº¦ã€ä»£ç†åˆçº¦

    // å…ˆæ˜ç¡®ä¸€ä¸ªé—®é¢˜ï¼šè´¦æˆ·åœ°å€æœ‰ä¸¤ç§ï¼šä¸€ç§æ˜¯å¤–éƒ¨è´¦æˆ·åœ°å€ï¼ˆå³å…·ä½“æŸä¸€ä¸ªäººçš„è´¦æˆ·åœ°å€ï¼‰ã€ä¸€ç§æ˜¯æ™ºèƒ½åˆçº¦è´¦æˆ·åœ°å€ï¼ˆå³å…·ä½“æŸä¸€ä¸ªæ™ºèƒ½åˆçº¦çš„è´¦æˆ·åœ°å€ï¼ŒåŒºåˆ«äºæŸä¸€ä¸ªäººçš„è´¦æˆ·åœ°å€ï¼‰ã€‚ä¸¤ç§è´¦æˆ·åœ°å€éƒ½èƒ½å­˜æ”¾ä»£å¸
    // ä¸¾ä¸ªä¾‹å­ï¼šè¿›è¡Œ1è´¦æˆ·åœ°å€Aä»£å¸ ä¸ 2è´¦æˆ·åœ°å€Bä»£å¸è¿›è¡Œè½¬æ¢çš„è¿‡ç¨‹ï¼šå³å…ˆæŠŠ1è´¦æˆ·åœ°å€Aä»£å¸ï¼Œè½¬ç»™æŸæ™ºèƒ½åˆçº¦ï¼Œç„¶å1è´¦æˆ·æˆæƒç»™æŸæ™ºèƒ½åˆçº¦ï¼Œæœ€åæ™ºèƒ½åˆçº¦æŠŠè‡ªå·±æ‹¥æœ‰çš„Bä»£å¸ï¼Œè½¬ç»™2è´¦æˆ·åœ°å€
    // å¤–éƒ¨è´¦æˆ·åœ°å€ï¼š0x5B38Da6a701c568545dCfcB03FcB875f56beddC4
    // åˆçº¦è´¦æˆ·åœ°å€ï¼š0xBc45c34fA3Eb75589fF3455Bd2d9410464205041

    // å…³é”®è¦ç‚¹ï¼šä¼˜å…ˆä½¿ç”¨æ¥å£è°ƒç”¨ã€å§‹ç»ˆè€ƒè™‘å®‰å…¨æ€§ã€ç†è§£æ‰§è¡Œä¸Šä¸‹æ–‡
    // ç†è§£çš„æ—¶å€™ï¼šæŠŠæ™ºèƒ½åˆçº¦ å’Œ è´¦æˆ·åœ°å€åˆ†å¼€ï¼Œå„æ˜¯å„çš„
}

// å®šä¹‰ERC20æ¥å£
interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

// ç®€å•çš„ERC20å®ç° - ï¼çŠ¶æ€å˜é‡éƒ½å­˜å‚¨åœ¨è¢«è°ƒç”¨åˆçº¦ä¸­
contract SimpleToken is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    constructor() {
        _balances[msg.sender] = 1000000 * 10**18;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance"); // ï¼msg.senderä¸ºå‡½æ•°è°ƒç”¨è€…ï¼ˆæ­¤å¤„æ˜¯ä»£å¸äº¤æ¢åˆçº¦è´¦æˆ·è°ƒç”¨ï¼Œå³åˆçº¦åœ°å€ï¼‰
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        return true;
    }
    
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        _allowances[msg.sender][spender] = amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(_allowances[from][msg.sender] >= amount, "Insufficient allowance"); // ï¼msg.senderä¸ºå‡½æ•°è°ƒç”¨è€…ï¼ˆæ­¤å¤„æ˜¯ä»£å¸äº¤æ¢åˆçº¦è´¦æˆ·è°ƒç”¨ï¼Œå³åˆçº¦åœ°å€ï¼‰
        require(_balances[from] >= amount, "Insufficient balance");
        
        _allowances[from][msg.sender] -= amount;
        _balances[from] -= amount;
        _balances[to] += amount;
        return true;
    }
}

// ä»£å¸äº¤æ¢åˆçº¦ï¼ˆä½¿ç”¨æ¥å£è°ƒç”¨ï¼‰- å³å®é™…ä¸ºï¼šä»£å¸äº¤æ¢åˆçº¦åœ¨ Aã€B åˆçº¦ä¸­éƒ½æœ‰ä¸€ä¸ªè´¦æˆ·ï¼Œç”¨æˆ· Aã€B ä»£å¸çš„è½¬æ¢
// å³Aåˆçº¦çš„ä¸€ä¸ªè´¦å·ï¼Œç»™Aåˆçº¦ä¸­çš„ä»£å¸äº¤æ¢åˆçº¦è´¦æˆ·è½¬å…¥10ä¸ªAå¸ï¼›ç„¶åä»Båˆçº¦çš„ä»£å¸äº¤æ¢åˆçº¦è´¦æˆ·è½¬å‡º10ä¸ªBå¸ï¼Œç»™Båˆçº¦çš„ä¸€ä¸ªè´¦å·
// å³Aåˆçº¦å’ŒBåˆçº¦éƒ½æœ‰ä¸€ä¸ªä¸­è½¬è´¦æˆ·ï¼Œå³ä»£å¸äº¤æ¢åˆçº¦è´¦æˆ·
contract TokenSwap {
    IERC20 public tokenA;
    IERC20 public tokenB;
    
    event Swap(address indexed user, uint256 amountA, uint256 amountB);
    
    constructor(address _tokenA, address _tokenB) {
        tokenA = IERC20(_tokenA);
        tokenB = IERC20(_tokenB);
    }
    
    function swap(uint256 amountA) external {
        // ä½¿ç”¨æ¥å£è°ƒç”¨ï¼Œç±»å‹å®‰å…¨
        require(tokenA.transferFrom(msg.sender, address(this), amountA), "Transfer A failed"); // ï¼æ­¤å¤„å°‘ä¸€ä¸ªå‰æï¼šapproveï¼›msg.senderä¸ºå‡½æ•°è°ƒç”¨è€…ï¼ˆæ­¤å¤„æ˜¯å¤–éƒ¨è´¦æˆ·è°ƒç”¨ï¼Œå³å¤–éƒ¨è´¦å·åœ°å€ï¼‰
        
        uint256 amountB = amountA; // ç®€åŒ–çš„1:1å…‘æ¢
        require(tokenB.transfer(msg.sender, amountB), "Transfer B failed");
        
        emit Swap(msg.sender, amountA, amountB);
    }
}

// å­˜åœ¨é‡å…¥æ¼æ´çš„åˆçº¦
contract VulnerableBank {
    mapping(address => uint256) public balances;
    
    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // å±é™©ï¼å­˜åœ¨é‡å…¥æ¼æ´
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance");
        
        // å…ˆè½¬è´¦ï¼Œåæ›´æ–°çŠ¶æ€ - è¿™æ˜¯é”™è¯¯çš„é¡ºåºï¼
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        balances[msg.sender] = 0;
    }
}

// å®‰å…¨çš„é“¶è¡Œåˆçº¦
contract SecureBank {
    mapping(address => uint256) public balances;
    bool private locked;
    
    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    
    modifier noReentrant() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // å®‰å…¨çš„æç°å‡½æ•°
    function withdraw() external noReentrant {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance");
        
        // æ£€æŸ¥-æ•ˆæœ-äº¤äº’æ¨¡å¼ï¼šå…ˆæ›´æ–°çŠ¶æ€
        balances[msg.sender] = 0;
        
        // å†è¿›è¡Œå¤–éƒ¨è°ƒç”¨
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        emit Withdrawal(msg.sender, amount);
    }
}

// æ”»å‡»åˆçº¦
contract Attacker {
    VulnerableBank public vulnerableBank;
    uint256 public attackCount;
    
    constructor(address _vulnerableBank) {
        vulnerableBank = VulnerableBank(_vulnerableBank);
    }
    
    // æ¥æ”¶ä»¥å¤ªå¸æ—¶è§¦å‘é‡å…¥æ”»å‡»
    receive() external payable {
        if (attackCount < 3 && address(vulnerableBank).balance > 0) {
            attackCount++;
            vulnerableBank.withdraw();
        }
    }
    
    function attack() external payable {
        require(msg.value >= 1 ether, "Need at least 1 ether");
        attackCount = 0;
        
        // å…ˆå­˜æ¬¾
        vulnerableBank.deposit{value: msg.value}();
        
        // å‘èµ·æ”»å‡»
        vulnerableBank.withdraw();
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// receive() external payable {} = åˆçº¦çš„æ”¯ä»˜å®/å¾®ä¿¡æ”¶æ¬¾ç ï¼Œè´´ä¸Šå°±èƒ½æ”¶é’±ï¼
// ä½ çš„ä»£ç å°±æ˜¯æœ€åŸºç¡€çš„ç‰ˆæœ¬ï¼Œè®©åˆçº¦å…·å¤‡äº†æ¥æ”¶ ETH çš„èƒ½åŠ›ã€‚å®é™…é¡¹ç›®ä¸­é€šå¸¸ä¼šæ·»åŠ æ›´å¤šé€»è¾‘ï¼ˆå¦‚è®°å½•ã€éªŒè¯ã€äº‹ä»¶ç­‰ï¼‰ã€‚
// receive() external payable {}ï¼šè¿™æ˜¯åˆçº¦çš„"æ”¶æ¬¾ç "ï¼Œè®©åˆçº¦èƒ½æ¥æ”¶åˆ«äººç›´æ¥è½¬æ¥çš„ ETH
// 1ã€åŸºæœ¬ç”¨æ³•ï¼š
// æœ€ç®€å•çš„æ¥æ”¶ETHæ–¹å¼
// receive() external payable {
//     // å½“åˆ«äººå‘åˆçº¦åœ°å€ç›´æ¥è½¬è´¦ETHæ—¶æ‰§è¡Œ
//     // ä¾‹ï¼šåœ¨é’±åŒ…é‡Œè¾“å…¥åˆçº¦åœ°å€ï¼Œè½¬1 ETH
// }
// 2ã€æ–¹å¼å¯¹æ¯”è¡¨
// è½¬è´¦æ–¹å¼	                è§¦å‘å“ªä¸ªå‡½æ•°ï¼Ÿ	    ç¤ºä¾‹
// ç›´æ¥è½¬ETHï¼Œæ— æ•°æ®	    receive()	        åˆçº¦åœ°å€.transfer(1 ETH)
// è½¬è´¦+è°ƒç”¨ä¸å­˜åœ¨çš„å‡½æ•°	fallback()	        åˆçº¦.call{value:1 ETH}("hello")
// è½¬è´¦+è°ƒç”¨å­˜åœ¨çš„å‡½æ•°	    å¯¹åº”å‡½æ•°ï¼ˆéœ€payableï¼‰	åˆçº¦.donate{value:1 ETH}()
// 3ã€å¦å¤–ï¼š
// receive() å‡½æ•°ï¼šè¿™æ˜¯ Solidity 0.6.0+ å¼•å…¥çš„ä¸“é—¨ç”¨äºæ¥æ”¶çº¯ ETH è½¬è´¦çš„ç‰¹æ®Šå‡½æ•°
// receive() external payable {
    // å½“åˆçº¦æ”¶åˆ°çº¯ETHè½¬è´¦æ—¶è‡ªåŠ¨æ‰§è¡Œ
    // ä¾‹å¦‚ï¼šç›´æ¥å‘åˆçº¦åœ°å€è½¬è´¦ï¼Œä¸é™„å¸¦ä»»ä½•æ•°æ®
// }
// receive() å’Œ payable fallback() åŒæ—¶å­˜åœ¨æ‰§è¡Œä¼˜å…ˆçº§ï¼šå…ˆæ‰¾åŒ¹é…çš„å‡½æ•°å â†’ æ‰§è¡Œï¼›æ²¡æœ‰åŒ¹é… â†’ æ£€æŸ¥æ˜¯å¦æœ‰ receive()ï¼ˆçº¯è½¬è´¦ï¼‰ï¼›æ²¡æœ‰ receive() â†’ æ‰§è¡Œ fallback()ï¼ˆå¦‚æœæœ‰ï¼‰
// contract Both {
//     receive() external payable {
//         // çº¯ETHè½¬è´¦æ—¶æ‰§è¡Œè¿™ä¸ª
//     } 
//     fallback() external payable {
//         // å¸¦æ•°æ®è°ƒç”¨æ—¶æ‰§è¡Œè¿™ä¸ª
//         // å¦‚æœæ˜¯çº¯è½¬è´¦ä¸”æ²¡æœ‰receive()ï¼Œä¹Ÿä¼šæ‰§è¡Œè¿™ä¸ª
//     }
// }
// çº¯ receive() å‡½æ•° - åªèƒ½æ¥æ”¶çº¯ETHè½¬è´¦ï¼ˆæ²¡æœ‰æ•°æ®ï¼‰
// fallback() å‡½æ•° - æ¥æ”¶çº¯ETHè½¬è´¦ï¼ˆæ²¡æœ‰æ•°æ®ï¼‰ã€ä¹Ÿå¤„ç†æœªçŸ¥å‡½æ•°è°ƒç”¨ï¼ˆå¸¦æ•°æ®ï¼‰ï¼›æ—¢å¤„ç†ï¼šsend(1 ether)ã€ä¹Ÿå¤„ç†ï¼šcall{value: 1 ether}("someData")
// è¿™æ˜¯æ™ºèƒ½åˆçº¦çš„"é“¶è¡Œè´¦æˆ·"åŠŸèƒ½â€”â€”å…è®¸åˆ«äººç»™ä½ æ‰“é’±ï¼

// uint public constant MAX_SUPPLY = 1_000_000; â€”â€” _æ•°å­—åˆ†éš”ç¬¦ã€æé«˜å¯è¯»æ€§ï¼ˆSolidity 0.7.0+æ”¯æŒï¼‰
// å¤§é‡‘é¢ä¸ºä½•3ä½ä¸€ç»„ï¼Œä¸å¤ªå¥½å•Šï¼šä½ è¯´å¾—å¯¹ï¼ä»æ•°å­¦å’Œç¼–ç¨‹è§’åº¦ï¼Œ3ä½ä¸€ç»„ç¡®å®ä¸æ˜¯æœ€è‡ªç„¶çš„ï¼Œç‰¹åˆ«æ˜¯å¯¹ä¸­å›½äººæ¥è¯´ã€‚è¿™å…¶å®æ˜¯å†å²å’Œä¹ æƒ¯çš„é—®é¢˜ã€‚
// 1ã€ä¸ºä»€ä¹ˆæ˜¯3ä½ä¸€ç»„ï¼Ÿè‹±è¯­å›½å®¶ä¹ æƒ¯ï¼š
// è‹±è¯­æ•°å­—è¯»æ³•ï¼š
// 1,000 = "one thousand"ï¼ˆåƒï¼‰
// 1,000,000 = "one million"ï¼ˆç™¾ä¸‡ï¼‰
// 1,000,000,000 = "one billion"ï¼ˆåäº¿ï¼‰
// æ¯3ä½ä¸€ä¸ªå•ä½åç§°ï¼
// 2ã€ä¸­å›½çš„4ä½åˆ†ç»„æ›´åˆç†ï¼š
// 10,0000 = "åä¸‡"ï¼ˆæ›´è‡ªç„¶ï¼‰
// 1,0000,0000 = "ä¸€äº¿"ï¼ˆäº¿æ˜¯8ä½ï¼‰
// ä¸­æ–‡æ˜¯4ä½ä¸€ä¸ªå•ä½ï¼
// 3.ã€ç¼–ç¨‹ä¸­çš„å°´å°¬
// è¥¿æ–¹ç¨‹åºå‘˜è§‰å¾—è‡ªç„¶ï¼š
// uint public constant MAX_SUPPLY = 1_000_000;  // 1 million
// ä¸­å›½ç¨‹åºå‘˜å¯èƒ½æ›´æƒ³è¦ï¼š
// uint public constant MAX_SUPPLY = 100_0000;  // 100ä¸‡
// ä½†è¿™æ ·å…¶ä»–å›½å®¶çš„å¼€å‘è€…çœ‹ä¸æ‡‚ ğŸ˜…
// 
// å¯¹æ¯”è¡¨ï¼š
// æ•°å­—	    è‹±æ–‡ï¼ˆ3ä½ç»„ï¼‰	    ä¸­æ–‡ï¼ˆ4ä½ç»„ï¼‰
// 1,000	thousand	        åƒ
// 10,000	ten thousand	    ä¸‡
// 100,000	hundred thousand	   åä¸‡
// 1,000,000	million	        ç™¾ä¸‡
// 10,000,000	ten million	    åƒä¸‡
// 100,000,000	hundred million	äº¿

// Token ä»£å¸è§£é‡Š: å³Web3 == Token
// 1. Token = åŒºå—é“¾ä¸Šçš„æ•°å­—èµ„äº§å‡­è¯ - æ ¸å¿ƒç‰¹å¾ï¼šæ•°å­—åŒ–ã€å¯ç¼–ç¨‹ã€å¯è½¬ç§»ã€å¯éªŒè¯
// 2. Token vs Coin åŒºåˆ«
//          Coinï¼ˆå¸ï¼‰	                Tokenï¼ˆä»£å¸ï¼‰
// åŒºå—é“¾	æœ‰è‡ªå·±çš„åŒºå—é“¾ï¼ˆBTCã€ETHï¼‰	ä¾èµ–å…¶ä»–åŒºå—é“¾ï¼ˆERC20åœ¨ä»¥å¤ªåŠä¸Šï¼‰
// ç”¨é€”	    æ”¯ä»˜ã€ä»·å€¼å­˜å‚¨	            ç‰¹å®šåº”ç”¨åœºæ™¯
// åˆ›å»º	    éœ€è¦å»ºç«‹æ•´ä¸ªåŒºå—é“¾	        åªéœ€éƒ¨ç½²æ™ºèƒ½åˆçº¦
// ä¾‹å­	    Bitcoinã€Ethereum	        USDTã€UNIã€AAVE
// 3. Token æ ‡å‡†ï¼ˆERCæ ‡å‡†ï¼‰- ERC-20 â­ï¼ˆæœ€å¸¸ç”¨ï¼‰ã€ERC-721 ğŸ–¼ï¸ï¼ˆNFTï¼‰ã€ERC-1155 ğŸ®ï¼ˆæ¸¸æˆ/å¤šä»£å¸ï¼‰
// 4. å¦‚ä½•åˆ›å»ºè‡ªå·±çš„ Tokenï¼Ÿç®€å• ERC20 ä»£å¸åˆçº¦ï¼šMyToken - è¿™é‡Œå°±çŸ¥é“ä¸ºå•¥å«MyTokenäº†ï¼Œæ­¤å¤„çš„åŒè´¨åŒ–ä»£å¸ï¼Œtokenéƒ½ä¸€æ ·ï¼Œï¼ï¼ï¼ä»£è¡¨ä¸€ä¸ªä»£å¸åˆçº¦ï¼›åŒºåˆ«ä¸ERC721çš„NFTéåŒè´¨åŒ–ä»£å¸ï¼Œæ¯ä¸ªtokenIdéƒ½ä¸ä¸€æ ·ï¼Œ!!!æ­¤å¤„ä»£è¡¨ä¸€ä¸ªNFT
// Token è®©ä¸€åˆ‡çš†å¯ä»£å¸åŒ–ï¼šä»è´§å¸åˆ°è‰ºæœ¯å“ï¼Œä»æŠ•ç¥¨æƒåˆ°æ¸¸æˆé“å…·ï¼ŒåŒºå—é“¾æ­£åœ¨ç”¨ Token é‡å¡‘æ•°å­—ä¸–ç•Œçš„ä»·å€¼è¡¨è¾¾æ–¹å¼ï¼

// æˆæƒè½¬è´¦åï¼Œè¢«æˆæƒäººè¿›è¡Œæˆæƒè½¬è´¦ï¼Œä¹Ÿè¦æ¶ˆè€—gasï¼Œé‚£ä¸ºä½•è¢«æˆæƒäººæ„¿æ„è¿›è¡Œæˆæƒè½¬è´¦å‘¢
// è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„é—®é¢˜ï¼è§¦åŠäº† DeFi ç»æµæ¨¡å‹çš„æ ¸å¿ƒã€‚è¢«æˆæƒäººï¼ˆå¦‚ Uniswapï¼‰ç¡®å®éœ€è¦æ”¯ä»˜ Gasï¼Œä½†ä»–ä»¬é€šè¿‡å•†ä¸šæ¨¡å¼å’Œæ¿€åŠ±æœºåˆ¶æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
// ========æ‰‹ç»­è´¹
// æ€»ç»“å›ç­”ä½ çš„é—®é¢˜ï¼š
// è¢«æˆæƒäººï¼ˆå¦‚ Uniswapï¼‰æ„¿æ„æ”¯ä»˜ Gas æ˜¯å› ä¸ºï¼š
// 1. æ‰‹ç»­è´¹æ”¶å…¥è¦†ç›–æˆæœ¬ï¼š0.3% æ‰‹ç»­è´¹è¿œé«˜äºå•ç¬” Gas æˆæœ¬
// 2. è§„æ¨¡æ•ˆåº”ï¼šæµ·é‡äº¤æ˜“æ‘Šè–„äº†å¹³å‡ Gas æˆæœ¬
// 3. ç”¨æˆ·é—´æ¥æ”¯ä»˜ï¼šGas æˆæœ¬é€šè¿‡æ‰‹ç»­è´¹ã€æ±‡ç‡å·®ç­‰å½¢å¼ç”±ç”¨æˆ·æ‰¿æ‹…
// 4. æˆ˜ç•¥ä»·å€¼ï¼šå³ä½¿çŸ­æœŸäºæŸï¼Œé•¿æœŸç”Ÿæ€ä»·å€¼å·¨å¤§
// 5. å•†ä¸šæ¨¡å¼è®¾è®¡ï¼šæ‰¹é‡å¤„ç†ã€Layer2ã€Gas è¡¥è´´ç­‰æŠ€æœ¯ä¼˜åŒ–
// æœ¬è´¨ä¸Šï¼šè¿™ä¸æ˜¯æ…ˆå–„ï¼Œè€Œæ˜¯ç²¾å¿ƒè®¾è®¡çš„å•†ä¸šæ¨¡å¼ï¼ç”¨æˆ·æ”¯ä»˜è´¹ç”¨ï¼Œåè®®æä¾›æœåŠ¡ï¼ŒGas åªæ˜¯è¿è¥æˆæœ¬çš„ä¸€éƒ¨åˆ†ã€‚åªè¦æ”¶å…¥ > æˆæœ¬ + Gasï¼Œè¿™ä¸ªç”Ÿæ„å°±èƒ½æŒç»­ã€‚
// å°±åƒæ·˜å®ä¸ä¼šå› ä¸ºè¦ä»˜æœåŠ¡å™¨è´¹ç”¨å°±ä¸åšç”Ÿæ„ä¸€æ ·â€”â€”æˆæœ¬æ˜¯ä¸šåŠ¡çš„ä¸€éƒ¨åˆ†ï¼Œå…³é”®æ˜¯æœ‰åˆ©æ¶¦ï¼ğŸ’°

// ä»£å¸äº¤æ¢åˆçº¦ã€ï¼Ÿå¤šç­¾é’±åŒ…ï¼ˆé‡å…¥é”ï¼‰ã€ï¼Ÿä»£ç†åˆçº¦ã€ï¼Ÿcreate2å·¥å‚